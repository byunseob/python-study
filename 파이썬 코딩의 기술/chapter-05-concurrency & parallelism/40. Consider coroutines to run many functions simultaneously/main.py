# 스레드는 3가지 문제가 있다
# 스레드들이 서로 안전하게 동작하도록 조율하려면 특별한 도구가 필요하다.
#  따라서 스레드를 사용하는 코드가 절차적인 싱글 스레드 코드보다 이해하기 어렵다.
#  또한 이런 복잡성 때문에 시간이 지날수록 스레드 코드를 확장하거나 유지보수하기 어렵다.

# 스레드에는 메모리가 많이 필요하다.(스레드당 약 8MB 정도)

# 스레드를 시작하는 데는 비용이 많이 든다. 끊임없이 새 병행 함수를 생성하고 종료하면
# 스레드를 사용하면서 드는 부하가 커져서 전체 시스템이 느려진다.

# 파이썬에서는 코루틴으로 이런 문제를 모두 해결한다.
# 코루틴을 이용하면 동시에 많은 함수를 실행하는 것처럼 보이게 할 수 있다.
# 제너레이터 코루틴을 시작하는 데 드는 비용은 함수 호출이다.
# 따라서 한 번 활성화 되면 소진될 때까지 1KB 미만의 메모리만 소비한다.

# 코루틴은 제너레이터를 소비하는 코드에서 send 함수를 사용하여
# 역으로 제너레이터 함수의 각 yield 표현식에 값을 보낼 수 있게 하는 방법으로 동작한다.
# 제너레이터 함수는 send 함수로 보낸 값을 대응하는 yield 표현식의 결과로 받는다.


def my_coroutine():
    while True:
        received = yield
        print(f'Received : {received}')


it = my_coroutine()
next(it)
it.send('First')
it.send('Second')


# yield  와 send 의 조합은 제너레이터가 외부 입력에 반응하여 다음 번에 다른 값을 얻게 하는 표준 방법이다.

def minimize():
    current = yield
    while True:
        value = yield current
        current = min(value, current)


it = minimize()
next(it)

print(it.send(10))
print(it.send(4))
print(it.send(22))
print(it.send(-11))

# 제너레이터 함수는 send 를 새로 호출할 때마다 전진하면서 계속 실행하는 것처럼 보인다.
# 스레드와 마찬가지로 코루틴은 주변 환경에서 받은 입력을 소비하여 결과를 만들어 낼 수 있는 독립적인 함수다.
# 둘의 차이는 코루틴이 제너레이터 함수의 각 yield 표현식에서 멈췄다가 외부에서 send 를 호출할 때마다 다시 시작한다는 점이다.

# 이 동작 덕분에 제너레이터를 소비하는 코드에서 코루틴의 각 yield 표현식 이후에 원하는 처리를 할 수 있다.
# 제너레이터를 소비하는 코드는 제너레이터의 출력값으로 다른 함수를 호출하고 자료 구조를 수정할 수 있다.
# 가장 중요한 건 다른 제너레이터 함수들을 yield 표현식 이전까지 전진 시킬 수 있다는 점이다.




